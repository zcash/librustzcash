//! Any and all errors encountered during parsing and validation.

use snafu::prelude::*;

use crate::Number;

/// Errors discovered during parsing.
#[derive(Debug, Snafu)]
#[snafu(visibility(pub(crate)))]
pub enum ParseError<'a> {
    /// A parsing error generated by `nom`.
    #[snafu(display("{}", nom::error::Error::to_string(&nom::error::Error {
        input: *input, code: *code
    })))]
    Nom {
        input: &'a str,
        code: nom::error::ErrorKind,
        other: Option<String>,
    },

    /// The number of digits did not match or exceed the expected minimum.
    #[snafu(display(
        "Expected at least {min} digits, saw {} before {}",
        digits.len(),
        input.split_at(10).0
    ))]
    DigitsMinimum {
        min: usize,
        digits: Vec<u8>,
        input: &'a str,
    },

    /// The ENS name was expected and missing.
    #[snafu(display("Missing ENS name"))]
    EnsMissing,

    /// The ENS name was not a valid domain.
    #[snafu(display("Not a domain"))]
    EnsDomain,

    /// The ENS name could not be normalized.
    #[snafu(display("{source}"))]
    EnsNormalization {
        source: ens_normalize_rs::ProcessError,
    },

    /// The ENS should be normalized, but wasn't.
    #[snafu(display("ENS name must be normalized. Expected '{expected}' but saw '{seen}'"))]
    NotNormalized { expected: String, seen: String },

    /// A parameter value had an unexpected value.
    #[snafu(display("Invalid parameter value. Expected a {ty}."))]
    InvalidParameterValue { ty: String },
}

impl<'a> nom::error::ParseError<&'a str> for ParseError<'a> {
    fn from_error_kind(input: &'a str, code: nom::error::ErrorKind) -> Self {
        NomSnafu {
            input,
            code,
            other: None,
        }
        .build()
    }

    fn append(input: &'a str, code: nom::error::ErrorKind, other: Self) -> Self {
        NomSnafu {
            input,
            code,
            other: Some(other.to_string()),
        }
        .build()
    }
}

impl<'a> From<ParseError<'a>> for nom::Err<ParseError<'a>> {
    fn from(value: ParseError<'a>) -> Self {
        if value.is_recoverable() {
            nom::Err::Error(value)
        } else {
            nom::Err::Failure(value)
        }
    }
}

impl ParseError<'_> {
    pub fn is_recoverable(&self) -> bool {
        true
    }
}

/// Errors discovered after parsing, usually when attempting to convert parsed
/// types into numeric types.
#[derive(Debug, Snafu, PartialEq)]
#[snafu(visibility(pub(crate)))]
pub enum ValidationError {
    #[snafu(display("Exponent is too small, expected at least {expected}, saw {seen}"))]
    SmallExponent { expected: usize, seen: u64 },

    #[snafu(display("Exponent is too large, expected at most {expected}, saw {seen}"))]
    LargeExponent { expected: usize, seen: u64 },

    #[snafu(display("Number {seen} is too big and has saturated"))]
    Saturation { seen: Number },

    #[snafu(display(
        "Arithmetic operation resulted in an overflow, exceeding the allowable range"
    ))]
    Overflow,

    #[snafu(display("Could not decode url-encoded string: {source}"))]
    UrlEncoding { source: std::str::Utf8Error },
}
